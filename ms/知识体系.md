### A：从输入 url 到获得页面经历的所有事情(越细越好)

    1、DNS解析，通过输入的域名，查找对应Ip地址。
        1.1	从浏览器-系统-路由器-域名服务器查询缓存
        1.2	若没有，则通过域名服务器查询到对应IP地址。
    2、建立TCP链接，进行三次握手建立连接
    3、发送HTTP请求报文，获取对应资源。
        3.0	资源会根据请求头的标示进行缓存。
            3.0.1:
            强缓存： Expires设置绝对时间，受本地时间影响
                    Cache-Control相对时间
            协商缓存：Last-Modified/If-Modified-Since本地文件最后修改时间。
                    ETag/If-None-Match根据资源变动产生唯一标识。
    4、获取到资源后。根据HTML渲染DOM树。根据CSS渲染CSSTree，将DOM树和CSS树合并为RenderTree。根据渲染树进行渲染。
        4.1	reflow回流：当元素结构、尺寸等发生改变触发。
        4.2	repaint重绘：当元素样式改变但不影响布局，触发。
    5、关闭TCP连接：4次分手。

### B： HTTP 和 HTTP2.0 的区别

    HTTP缺点：
        1.浏览器阻塞：一个浏览器至多发送4-6个请求。超过连接数会被阻塞。
        2.DNS查询：需要解析域名消耗时间
        3.建立连接需要3次握手，并且有慢启动影响（刚建立连接，速度会由慢变快）

    HTTP1.x相对于HTTP1.0的升级：
        1.增加了更多的缓存头，比如ETag。
        2.增加新的返回码，如206，307
            206:请求头会带一个Range，代表发送一个部分内容请求.该请求头Range表明了客户端需要请求资源的哪一部分
            307:类似302，但不会直接发送GET请求而是问询用户。不会将POST转为GET
        3.新增部分错误码，如410（永久删除）
        4.HOST头处理，因为物理服务器可能存在多个虚拟机。
        5.长链接：在一个TCP连接上可以传送多个HTTP请求，减少建立和关闭延迟。但是多个请求必须等待上一个请求完成。

    HTTPS安全升级：
        1.在HTTP上增加了SSL/TLS秘文。即HTTP先与SSL通信，再由SSL和TCP通信。
        2.密钥：
            2.1对称蜜钥：加解密相同蜜钥。
            2.2公开蜜钥（非对称密钥）：同时拥有公开密钥和私有密钥。

    HTTPS带来的性能问题：
        1.会降低用户访问速度。
        2.大量计算导致消耗服务资源。

    HTTP2.0：
        1.采用二进制协议：头部信息和数据体都是二进制，统称为帧（通信最小单位）。而HTTP1则是基于文本格式(文本编码多样性，导致不健壮）。
        2.首部压缩：
            2.1、头部信息会经过压缩后发送；
            2.2、客户端与服务端会共同维护一个头部信息表，通过索引号发送头部信息。
        3.流量控制根据流的帧来控制
        4.多路复用：复用TCP连接，在一个链接里可以发送多个请求和回应。并且可以很多时间内发送多个请求而不必等待回应。接受response时也可以不按照请求顺序。每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。
        5.请求优先级：流带有优先级标示，服务端根据标识相应数据
        6.服务器推送：允许服务端未经过请求向客户端推送数据。

### C：深度拷贝

```js
deepClone(obj, hash = new WeeKMap()) {
    if(obj === null || obj === undefined || hash.has(obj)) return obj;

    var dobj = null;

    let t = typeof obj;
    switch(t) {
        case:'string':
        case:'number':
        case:'boolean':
            return obj;
    };

    if(Array.isArray(obj)) {
        dobj = [];
        obj.map((el, index) => {
            dobj.push(deepClone(el));
        })
    }else {
        dobj = {};
        if(Object.prototype.toString.call(obj).slice(8, -1) === 'Object') {
            Object.getOwnPropertyNames(obj)
                .concat(Object.getOwnPropertySymbols(obj)).map(el => {
                    hash.set(obj, obj);
                    dobj[el] = deepClone(obj[el], hash);
                })
        }else {
            dobj = obj;
        }
    }
    return dobj;
}
```

### D: Promise 原理以及手写代码

```js

```

### E：DOM Diff 和 Vue3 中的提升：

https://blog.csdn.net/kameleon2013/article/details/89218685

### F：前端性能优化：

    1. zip压缩，减小资源体积。
    2. 去除无用代码（类似console）
    3. 去除一些资源文件打包，采用CDN（利用缓存）
    4. 采用 serverWorker 预加载资源，控制资源
    5. HTTP缓存（强/协商）
    6. HTTP2.0（多路复用/二进制/头部压缩，表/服务端推送资源/资源流量控制/资源优先级控制）
    7. 资源预加载（
        1. preload适用于当前页面-主体渲染之前开始加载，加载后不执行
        2. prefetch适用于其他将要加载的页面，利用空闲时间加载，切换页面不会中断加载，有缓存。
    8. js资源异步加载
        1. defer-在其他资源加载完毕后，onload执行签开始执行，不阻塞页面
        2. async-加载完后立即执行，加载时不阻塞页面。
    9. 图片压缩
    10. 图片懒加载
    11. 骨架屏
    12. 打包时预渲染

### G：async/Promise 区别

    async 返回的就是一个Promise，但是他不再使用链式调用，书写更清晰，阅读更简便。

### H：箭头函数和声明函数的区别

    1. 箭头函数没有原型prototype，即没有自己的this对象
    2. 箭头函数的this指向调用他的外层环境对象。而function则指向顶级对象。
    3. apply/bind/call 不会改变箭头函数指向
    4. 箭头函数不能作为构造函数
    5. 箭头函数没有arguments
    6. 箭头函数不能用作Generator函数，不能使用yield关键字

### I: 宏任务微任务

### J：手动实现 call(), apply(), bind()

    https://juejin.im/post/6859642206601347080

### K：非严格模式和严格模式的区别

    https://juejin.im/post/6844904129442086925

### L：Vue.nextTick

    https://juejin.im/entry/6844903590293684231

### M：webpack tree shaking

### N：requestAnimation

### O：节流/防抖

### P：new 过程都发生了什么

### Q：如何遍历对象(接下来会问有何不同)

### R：文件上传

### S：Object.defineProperties 都有那些参数,以及参数解释

### T：CSRF & XSS

### U：vue router 原理/Vuex 稍微了解

### V：盒子模型/标签

### W：v-model 实现原理

### X：跨域形成原因以及解决方案

### Y：最近技术

### Z：自我介绍

### 算法

排序算法(冒泡,快排)
洗牌算法
v1.2.3 v0.3.0 这样的版本号比大小(找简单方法,不要随便写一个循环的版本)
广度优先遍历
用 O(n)的复杂度合并两个有序数组
数组生成树形结构
