建立一个静态资源服务器的思路：

需求：
    我们要开发的是一个简单的静态文件合并服务器，该服务器需要支持类似以下格式的JS或CSS文件合并请求。
    eg：http://assets.example.com/foo/??bar.js,baz.js

1、
    1) 服务器会首先分析URL，得到请求的文件的路径和类型（MIME）。然后，服务器会读取请求的文件，并按顺序合并文件内容。最后，服务器返回响应，完成对一次请求的处理。
    2) 服务器在读取文件时需要有个根目录，并且服务器监听的HTTP端口最好也不要写死在代码里，因此服务器需要是可配置的。
                +---------+   +-----------+   +----------+
    request --> |  parse  |-->|  combine  |-->|  output  |--> response
                +---------+   +-----------+   +----------+
    (请求)         (解析)        (结合)            (输出)       (应答)

2、
    1) 接下来我们需要从性能的角度出发，看看代码还有哪些改进余地。
    2) 把map方法换成for循环或许会更快一些，但第一版代码最大的性能问题存在于从读取文件到输出响应的过程当中
    发送请求       等待服务端响应         接收响应
---------+----------------------+------------->
         --                                        解析请求
           ------                                  读取a.js
                 ------                            读取b.js
                       ------                      读取c.js
                             --                    合并数据
                               --                  输出响应
    3) 可以看到，第一版代码依次把请求的文件读取到内存中之后，再合并数据和输出响应。这会导致以下两个问题：
        1.当请求的文件比较多比较大时，串行读取文件会比较耗时，从而拉长了服务端响应等待时间。
        2.由于每次响应输出的数据都需要先完整地缓存在内存里，当服务器请求并发数较大时，会有较大的内存开销。
    4) 正确做法:
        一边读取文件一边输出响应，把响应输出时机提前至读取第一个文件的时刻。这样调整后，整个请求处理过程变成下边这样。
    发送请求 等待服务端响应 接收响应
---------+----+------------------------------->
         --                                        解析请求
           --                                      检查文件是否存在
             --                                    输出响应头
               ------                              读取和输出a.js
                     ------                        读取和输出b.js
                           ------                  读取和输出c.js

3、利用child_process对进程进行监控，非正常退出的进行重启
    关键词：spawn、worker.on、process.on、 worker.kill、 process.exit。